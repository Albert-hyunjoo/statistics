# 회귀분석과 유의성 검정

## 개별 계수 추정치의 표준오차
* `단순회귀분석` 모형에서 표본에서 **상수항**과 **기울기**를 출력한다.
* 당연히 `표본`은 일정하지 않으므로 **상수항**과 **기울기**는 바뀌는데, 얼마나 바뀌나를 `표준오차`를 통해 파악한다.
* 어떠한 모집단의 단순회귀분석 모형의 **절편**과 **기울기** 추정량의 **표준오차**가 `SE(a)`와 `SE(b)`라고 가정하고     
  추정치를 `SE(a)_hat`과 `SE(b)_hat`이라고 한다면,
  > `SE(a)` = δ * √((1/n) + (표본평균^2 / (편차의 제곱의 합)))    
  > `SE(b)` = δ / √((편차의 제곱 합))    
  > `SE(a)_hat` = `δ_hat` * √((1/n) + (표본평균^2 / (편차의 제곱의 합)))    
  > `SE(b)_hat` = `δ_hat` / √((편차의 제곱 합))      
  > 여기서 `δ_hat`은 회귀분석 오차의 표준편차의 추정치로,    
  > `δ_hat` = √((값 편차의 제곱의 합)/(개수-2))

## 개별 계수에 대한 추론 : 신뢰구간의 구축 및 t-검정
* 회귀분석을 한 다음에는 통상적으로 
  > `y_hat` = a (SE(a)) + bx (SE(b)) 형태    
  > + 관측자수: n , 결정계수 = R^2, 추정의 표준오차 = `δ_hat`
* 여기서 귀무가설 `H0: β = 상수`를 토대로 검정하면 95% 기준으로 `b + 2SE(b)`가 나온다.
* 이것은 곧 귀무가설 하에서 주어진 값의 포함 여부를 판단하는 강력한 개체
* 만약 `t-검정`을 사용하려 할 때에는 측정값과 귀무가설 상수를 `SE(b)`, 즉 **표준오차 단위**로 나타낸다.
* 통상적으로 이 검정값이 **2**를 초과하면, 이는 **귀무가설** 기각 요인이다.

## 예측의 표준오차
* 예측은 두 가지로 `개별값`의 예측과 `평균`의 예측이 있다.
* 둘 다 `y_hat = a + bx0`를 쓰는 건 같지만 그 표준오차의 표시 및 종류는 다르다.
> 단순회귀 모형 상에서 개별값 예측 및 평균값 예측을 하려면 :    
> `SE(y0 - y0_hat)` = `개별값의 예측 표준오차`     
> = `δ` * √(1 + 1/n + (X0의 평균 사이 편차)^2 / (Xi과 평균 사이 편차)^2의 합)    
> `SE(Ey0 - y0_hat)` = `평균값 예측의 표준오차`    
> = `δ`* √(1/n + (X0의 평균 사이 편차)^2 / (Xi과 평균 사이 편차)^2의 합)    
> 
> *추정은 `δ`를 `δ_hat`으로 대체함으로써 구할 수 있다.*    
> *개별값 예측의 표준오차가 더 많으며, 이는 개별값을 예측하기가 더 힘듬을 의미한다.*    
> *상수항의 추정치는 설명변수의 값이 0일때 평균 y값이므로, 이를 반영해서 x0 = 0의 경우 `SE(a)`와 갍다.*

## 런 검정 (Run-Test)에 대해서
* 상수항이 있는 모형에서 회귀분석을 하고 나면 잔차의 평균은 보통 0이다.
* 인접한 잔차 사이에 `계열상관`이 있는지를 파악하기 위해 잔차들의 부호를 나열해야 한다.
* 이 잔차들의 부호가 바뀌는 시점을 `run`이라고 하며, 부호의 연속성이 *높을수록* *양의 계열상관*을 보인다.
> **[RUN 검정에 대해서]**    
> 런-검정의 가장 큰 목적은 어떠한 시계열이 무작위성을 띄는지를 통계적으로 확인하기 위함이다.    
> 
> > *런 검정의 귀무가설 및 대립가설*     
> H0 : 연속적인 관측값은 **임의적**이다.   
> -> 이 경우에는 상/하한 임계치의 범위 안에 들어가는 경우    
> H1 : 연속적인 관측값은 **임의적이지 않다.**    
> -> 상/하한 임계치 범위 안에 들어가지 *않은* 경우
> 
> > *런 검정에서 쓰이는 검정통계량*     
> `n_k`: 변환된 데이터에서 부호만 고려한 run의 수    
> `n`: `n_1` + `n_2` (여기서 상/하한 임계치를 확인)    
> `u`: run의 총 횟수    
> (μ) = 2 * n_1 * n_2 / (n_1 + n_2) + 1    
> (δ^2) = 2 * n_1 * n_2 * (2n_1n_2 - n_1 - n_2) / (n_1 + n_2)^2 * (n_1 + n_2 - 1)    
> (대표본인 경우 z-값) = (u - μ) / δ ~ *N(0,1)*    
> >>**[소표본인 경우에 정확도를 높이려면?]**    
> 만약 u < 2n_1n_2 / (n_1 + n_2) + 0.5면 h는 **+0.5**    
> 만약 u > 2n_1n_2 / (n_1 + n_2) + 0.5면 h는 **-0.5**    
> z-value = u + h - 2n_1n_2/(n1*n2-n1-n2) / (n1+n2)^2(n1+n2-1)
